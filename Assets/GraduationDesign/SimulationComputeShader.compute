//--------------内核定义----------------//
#pragma kernel CSMain

//--------------基础数据结构定义----------------//
struct granule_data_type
{
    float3 position;
    float3 velocity;
    float3 angular_velocity;
    float4 quaternion;
};

struct plane_data_type
{
    float3 normal;
    float3 origin;
    float3 a_axis;
    float3 b_axis;
    float particle_radius;
};

//--------------Compute Buffer定义----------------//
RWStructuredBuffer<float3> particle_position_rw_structured_buffer;                                  //粒子位置
RWStructuredBuffer<float3> particle_velocity_rw_structured_buffer;                                  //粒子速度
RWStructuredBuffer<granule_data_type> granule_data_rw_structured_buffer;                            //Granule数据
ConsumeStructuredBuffer<granule_data_type> granule_data_consume_structured_buffer;                  //Granule数据，用于动态添加
RWStructuredBuffer<plane_data_type> plane_data_rw_structured_buffer;                                //平面数据

//--------------变量定义----------------//
float delta_time;                                                                                   //时间步长
uint current_granule_count;                                                                          //当前Granule数量
uint max_granule_count;                                                                              //最大Granule数量
uint current_particle_count;                                                                         //当前粒子数量
uint max_particle_count;                                                                             //最大粒子数量
float particle_mass;                                                                                //粒子质量
float particle_radius;                                                                              //粒子半径
uint consume_granule_count;                                                                          //消耗Granule数量
uint buffer_index_begin;                                                                             //缓冲区索引开始,这里主要用于处理双缓冲,值为0或1
float k_d;                                                                                        //viscous damping coefficient(粘性阻尼系数)                                                    
float k_r;                                                                                          //elastic restoration coefficient(弹性恢复系数)
float mu;                                                                                           //friction coefficient(摩擦系数)
float k_t;                                                                                          //tangential stiffness coefficient(切向刚度系数)
float4x4 I_inverse_initial;                                                                         //初始转动惯量的逆矩阵
uint plane_count;                                                                                   //平面数量
//--------------函数定义----------------//
float3 get_now_particle_position(uint index);
float3 get_now_particle_velocity(uint index);
granule_data_type get_now_granule_data(uint index);
void set_now_particle_position(uint index, float3 position);
void set_now_particle_velocity(uint index, float3 velocity);
void set_now_granule_data(uint index, granule_data_type granule_data);
void set_next_state_particle_position(uint index, float3 position);
void set_next_state_particle_velocity(uint index, float3 velocity);
void set_next_state_granule_data(uint index, granule_data_type granule_data);
uint get_now_particle_index(uint particle_index);
uint get_now_granule_index(uint granule_index);
uint get_next_state_particle_index(uint particle_index);
uint get_next_state_granule_index(uint granule_index);
uint get_granule_index_of_particle(uint particle_index);
uint get_first_particle_index_of_granule(uint granule_index);
float3 get_particle_position_offset(uint particle_index);                                           //获取粒子位置偏移(相对于Granule)
float3x3 QuaternionToMatrix(float4 quaternion);                                                      //四元数转矩阵
void Simulation(uint3 granuleIndex : SV_DispatchThreadID);
void UpdateParticle(uint particleIndex,granule_data_type granule_data);
void UpdateGranule(uint granuleIndex);
float3 get_particle_force(uint particle_index);                                                           //particle所受力
float3 calculate_contact_force_between_two_particle(const uint particle_index1,const uint particle_index2,const float R1,const float R2); //计算两个粒子之间的接触力
float3 calculate_contact_force_between_two_particle(const float3 particle_position1,const float3 particle_position2,const float3 particle_velocity1,const float3 particle_velocity2,const float R1,const float R2); //计算两个粒子之间的接触力
float4 quaternionMul(float4 q1,float4 q2);
float3 calculate_contact_force_with_plane(const uint particle_index, const float R,const uint plane_index);
//--------------常量定义----------------//
//取消常量定义
static const int3 grid_offset[27] = {
    int3(-1,-1,-1),int3(-1,-1,0),int3(-1,-1,1),
    int3(-1,0,-1),int3(-1,0,0),int3(-1,0,1),
    int3(-1,1,-1),int3(-1,1,0),int3(-1,1,1),
    int3(0,-1,-1),int3(0,-1,0),int3(0,-1,1),
    int3(0,0,-1),int3(0,0,1),int3(0,0,0),
    int3(0,1,-1),int3(0,1,0),int3(0,1,1),
    int3(1,-1,-1),int3(1,-1,0),int3(1,-1,1),
    int3(1,0,-1),int3(1,0,0),int3(1,0,1),
    int3(1,1,-1),int3(1,1,0),int3(1,1,1)
};
static const float3 tetrahedron[4] = {                        
    float3(1,0,-1/sqrt(2)),
    float3(-1,0,-1/sqrt(2)),
    float3(0,1,1/sqrt(2)),
    float3(0,-1,1/sqrt(2))
};
static const float3 g = float3(0,-9.8,0);



//--------------函数实现----------------//
float3 get_now_particle_position(uint index)
{
    return particle_position_rw_structured_buffer[get_now_particle_index(index)];
}
float3 get_now_particle_velocity(uint index)
{
    return particle_velocity_rw_structured_buffer[get_now_particle_index(index)];
}
granule_data_type get_now_granule_data(uint index)
{
    return granule_data_rw_structured_buffer[get_now_granule_index(index)];
}
void set_now_particle_position(uint index, float3 position)
{
    particle_position_rw_structured_buffer[get_now_particle_index(index)]=position;
}
void set_now_particle_velocity(uint index, float3 velocity)
{
    particle_velocity_rw_structured_buffer[get_now_particle_index(index)]=velocity;
}
void set_now_granule_data(uint index, granule_data_type granule_data)
{
    granule_data_rw_structured_buffer[get_now_granule_index(index)]=granule_data;
}
void set_next_state_particle_position(uint index, float3 position)
{
    particle_position_rw_structured_buffer[get_next_state_particle_index(index)]=position;  
}
void set_next_state_particle_velocity(uint index, float3 velocity)
{
    particle_velocity_rw_structured_buffer[get_next_state_particle_index(index)]=velocity;
}
void set_next_state_granule_data(uint index, granule_data_type granule_data)
{
    granule_data_rw_structured_buffer[get_next_state_granule_index(index)]=granule_data;
}
uint get_now_particle_index(uint particle_index)
{
    return particle_index+buffer_index_begin*max_particle_count;
}
uint get_now_granule_index(uint granule_index)
{
    return granule_index+buffer_index_begin*max_granule_count;
}
uint get_next_state_particle_index(uint particle_index)
{
    return particle_index+(1-buffer_index_begin)*max_particle_count;
}
uint get_next_state_granule_index(uint granule_index)
{
    return granule_index+(1-buffer_index_begin)*max_granule_count;
}
uint get_granule_index_of_particle(uint particle_index)
{
    return particle_index/4;
}
uint get_first_particle_index_of_granule(uint granule_index)
{
    return granule_index*4;
}
float3 get_particle_position_offset(uint particle_index)
{
    return tetrahedron[particle_index%4]*particle_radius;
}
float3x3 QuaternionToMatrix(float4 quaternion)
{
    float3x3 result;
    float s= quaternion.x;
    float3 v = quaternion.yzw;
    result[0][0] = 1-2*v.y*v.y-2*v.z*v.z;
    result[0][1] = 2*v.x*v.y-2*s*v.z;
    result[0][2] = 2*v.x*v.z+2*s*v.y;
    result[1][0] = 2*v.x*v.y+2*s*v.z;
    result[1][1] = 1-2*v.x*v.x-2*v.z*v.z;
    result[1][2] = 2*v.y*v.z-2*s*v.x;
    result[2][0] = 2*v.x*v.z-2*s*v.y;
    result[2][1] = 2*v.y*v.z+2*s*v.x;
    result[2][2] = 1-2*v.x*v.x-2*v.y*v.y;
    return result;
}
float4 quaternionMul(float4 q1,float4 q2)
{
    float4 result;
    float s1 = q1.x;
    float s2 = q2.x;
    float3 v1 = q1.yzw;
    float3 v2 = q2.yzw;

    result.x = s1*s2-dot(v1,v2);
    result.yzw = s1*v2+s2*v1+cross(v1,v2);
    
    return result;
}
[numthreads(32,1,1)]
void CSMain (uint3 granuleIndex : SV_DispatchThreadID)
{
    Simulation(granuleIndex);
}

void Simulation(uint3 granuleIndex : SV_DispatchThreadID)
{
    UpdateGranule(granuleIndex.x);
}

void UpdateGranule(uint granuleIndex)
{
    if(granuleIndex>=current_granule_count)
    {
        return;
    }
    const granule_data_type granule_data = get_now_granule_data(granuleIndex);
    const uint first_particle_index=get_first_particle_index_of_granule(granuleIndex);
    const float3 force1=get_particle_force(first_particle_index);
    const float3 force2=get_particle_force(first_particle_index+1);
    const float3 force3=get_particle_force(first_particle_index+2);
    const float3 force4=get_particle_force(first_particle_index+3);

    const float3 sum_force=force1+force2+force3+force4;
    const float3 particle_position_offset1=get_now_particle_position(first_particle_index)-granule_data.position;
    const float3 particle_position_offset2=get_now_particle_position(first_particle_index+1)-granule_data.position;
    const float3 particle_position_offset3=get_now_particle_position(first_particle_index+2)-granule_data.position;
    const float3 particle_position_offset4=get_now_particle_position(first_particle_index+3)-granule_data.position;
    const float3 torque=cross(particle_position_offset1,force1)+cross(particle_position_offset2,force2)+cross(particle_position_offset3,force3)+cross(particle_position_offset4,force4);
    const float3x3 rotation_matrix = QuaternionToMatrix(granule_data.quaternion);
    const float3x3 I_ref_inv={I_inverse_initial[0][0],I_inverse_initial[0][1],I_inverse_initial[0][2],
                              I_inverse_initial[1][0],I_inverse_initial[1][1],I_inverse_initial[1][2],
                              I_inverse_initial[2][0],I_inverse_initial[2][1],I_inverse_initial[2][2]};
    const float3x3 I_inv=mul(rotation_matrix,mul(I_ref_inv,transpose(rotation_matrix)));
    const float3 angular_acceleration=mul(I_inv,torque);
    const float3 angular_velocity=granule_data.angular_velocity+angular_acceleration*delta_time;
    const float3 velocity=granule_data.velocity+sum_force/particle_mass*delta_time;
    const float3 position=granule_data.position+velocity*delta_time;
    const float4 quaternion=normalize(granule_data.quaternion+quaternionMul(float4(0,angular_velocity),granule_data.quaternion)*delta_time*0.5);
    granule_data_type granule_data_new;
    granule_data_new.position=position;
    granule_data_new.velocity=velocity;
    granule_data_new.angular_velocity=angular_velocity;
    granule_data_new.quaternion=quaternion;
    
    

    set_next_state_granule_data(granuleIndex,granule_data_new);
    
    UpdateParticle(first_particle_index,granule_data_new);
    UpdateParticle(first_particle_index+1,granule_data_new);
    UpdateParticle(first_particle_index+2,granule_data_new);
    UpdateParticle(first_particle_index+3,granule_data_new);
}

void UpdateParticle(uint particleIndex,granule_data_type granule_data)
{
    float3x3 rotation_matrix = QuaternionToMatrix(granule_data.quaternion);
    float3 particle_position=granule_data.position+mul(rotation_matrix,get_particle_position_offset(particleIndex));
    float3 particle_velocity=granule_data.velocity+cross(granule_data.angular_velocity,particle_position-granule_data.position);

    set_next_state_particle_position(particleIndex,particle_position);
    set_next_state_particle_velocity(particleIndex,particle_velocity);
}

float3 get_particle_force(uint particle_index)
{
    float3 res=particle_mass*g;
    // for(uint i=0;i<current_particle_count;i++)
    // {
    //     res+=calculate_contact_force_between_two_particle(particle_index,i,particle_radius,particle_radius);
    // }
    for(uint i=0;i<plane_count;i++)
    {
        res+=calculate_contact_force_with_plane(particle_index,particle_radius,i);
    }
    return res;
}

float3 calculate_contact_force_with_plane(const uint particle_index, const float R,const uint plane_index)
{
    float3 res=float3(0,0,0);
    const float3 particle_position=get_now_particle_position(particle_index);
    const float3 particle_velocity=get_now_particle_velocity(particle_index);
    const plane_data_type plane_data=plane_data_rw_structured_buffer[plane_index];

    const float3 particle_position_offset=particle_position-plane_data.origin;
    const float3 a_axis=normalize(plane_data.a_axis);
    const float3 b_axis=normalize(plane_data.b_axis);
    const float3 particle_position_in_plane_space={dot(particle_position_offset,a_axis),dot(particle_position_offset,plane_data.normal),dot(particle_position_offset,b_axis)};
    const float r=sqrt(R*R-particle_position_in_plane_space.y*particle_position_in_plane_space.y);
    //找到相交的Particle
    const float x_min=max(0,particle_position_in_plane_space.x-r);
    const float x_max=min(length(plane_data.a_axis),particle_position_in_plane_space.x+r);
    const float y_min=max(0,particle_position_in_plane_space.z-r);
    const float y_max=min(length(plane_data.b_axis),particle_position_in_plane_space.z+r);

    const uint x_min_index=floor(x_min/plane_data.particle_radius/2);
    const uint x_max_index=ceil(x_max/plane_data.particle_radius/2);
    const uint y_min_index=floor(y_min/plane_data.particle_radius/2);
    const uint y_max_index=ceil(y_max/plane_data.particle_radius/2);

    for (uint x=x_min_index;x<=x_max_index;x++)
        for (uint y=y_min_index;y<=y_max_index;y++)
        {
            const float3 pos_in_world=plane_data.origin+a_axis*x*plane_data.particle_radius*2+b_axis*y*plane_data.particle_radius*2;
            if (distance(particle_position,pos_in_world)<R)
            {
                res+=calculate_contact_force_between_two_particle(particle_position,pos_in_world,particle_velocity,float3(0,0,0),R,plane_data.particle_radius);
            }
        }
    
    return res;
}

float3 calculate_contact_force_between_two_particle(const uint particle_index1,const uint particle_index2,const float R1,const float R2)
{
    if(particle_index1==particle_index2)return float3(0,0,0);
    const float3 particle_position1=get_now_particle_position(particle_index1);
    const float3 particle_position2=get_now_particle_position(particle_index2);
    const float3 particle_velocity1=get_now_particle_velocity(particle_index1);
    const float3 particle_velocity2=get_now_particle_velocity(particle_index2);
    return calculate_contact_force_between_two_particle(particle_position1,particle_position2,particle_velocity1,particle_velocity2,R1,R2);
}

float3 calculate_contact_force_between_two_particle(const float3 particle_position1,const float3 particle_position2,const float3 particle_velocity1,const float3 particle_velocity2,const float R1,const float R2)
{
    const float3 particle_2_relative_position=particle_position2-particle_position1;
    const float distance_between_particles=length(particle_2_relative_position);
    const float overlap_normal=R1+R2-distance_between_particles;
    if (overlap_normal<=0)return float3(0,0,0);
    const float3 normal_unit_vector=particle_2_relative_position/distance_between_particles;
    const float3 r1=(R1-overlap_normal/2)*normal_unit_vector;
    const float3 r2=-(R2-overlap_normal/2)*normal_unit_vector;
    const float3 contact_point=particle_position1+r1;
    const float3 contact_point_v1=particle_velocity1+cross(particle_velocity1,contact_point-particle_position1);
    const float3 contact_point_v2=particle_velocity2+cross(particle_velocity2,contact_point-particle_position2);
    const float3 v_relative=contact_point_v1-contact_point_v2;
    const float3 v_relative_normal=dot(v_relative,normal_unit_vector)*normal_unit_vector;
    const float3 v_relative_tangent=v_relative-v_relative_normal;

    //计算法向力
    const float f_n=-(-k_d*pow(overlap_normal,0.5)*length(v_relative_normal)-k_r*pow(overlap_normal,1.5));
    const float3 f_n_vector=f_n*normal_unit_vector;

    //计算切向力
    const float f_t=-min(mu*f_n,k_t*length(v_relative_tangent));
    const float3 f_t_vector=f_t*normalize(v_relative_tangent);
    
    return f_n_vector;
}

//链表改为排序
//float直接转int比大小

