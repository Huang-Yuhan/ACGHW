// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

struct GranuleDataType
{
    float3 position;
    float3 velocity;
    float3 angularVelocity;
    float4 quaternion;
};

RWStructuredBuffer<float3> _ParticlePositionBuffer;
RWStructuredBuffer<float3> _ParticleVelocityBuffer;
RWStructuredBuffer<GranuleDataType> _GranuleBuffer;
float _DeltaTime;
int _GranuleCount;
float _ParticleMass;
float _ParticleRadius;
float _ViscousDampingCoefficient;
float _ElasticityRestoringCoefficient;
float _FrictionCoefficient;
float _VelocityDampingCoefficient;


static const float3 tetrahedron[4] = {                        
    float3(1,0,-1/sqrt(2)),
    float3(-1,0,-1/sqrt(2)),
    float3(0,1,1/sqrt(2)),
    float3(0,-1,1/sqrt(2))
};
static const 

void CSMain();
void TestSimulation(uint3 granuleIndex : SV_DispatchThreadID);
void UpdateParticle(uint particleIndex);
void UpdateGranule(uint granuleIndex);
float3x3 QuaternionToMatrix(float4 quaternion);
float3 ParticleContactForceSum(uint particleIndex);         //计算particle的接触力
float3 CalculateContactForce(uint particleIndex1,uint particleIndex2);    //计算两个particle之间的接触力，返回的是particle1受到的力


inline uint GetGranuleIndex(uint particleIndex)
{
    return particleIndex/4;
}
inline uint GetFirstParticleIndex(uint granuleIndex)
{
    return granuleIndex*4;
}

float3 getParticleOffset(uint particleIndex)
{
    return tetrahedron[particleIndex%4]*_ParticleRadius/2;
}

[numthreads(64,1,1)]
void CSMain (uint3 granuleIndex : SV_DispatchThreadID)
{
    TestSimulation(granuleIndex);
}

void TestSimulation(uint3 granuleIndex : SV_DispatchThreadID)
{

    UpdateGranule(granuleIndex.x);

}

void UpdateGranule(uint granuleIndex)
{
    uint firstParticleIndex = GetFirstParticleIndex(granuleIndex);

    float3 sumForce = float3(0,-9.8,0);
    sumForce+= ParticleContactForceSum(firstParticleIndex);
    sumForce+= ParticleContactForceSum(firstParticleIndex+1);
    sumForce+= ParticleContactForceSum(firstParticleIndex+2);
    sumForce+= ParticleContactForceSum(firstParticleIndex+3);

    float3 granuleAcceleration = sumForce/_ParticleMass;
    
    GranuleDataType granule = _GranuleBuffer[granuleIndex];
    float3 granulePosition = granule.position;
    float3 granuleVelocity = granule.velocity;
    float3 granuleAngularVelocity = granule.angularVelocity;
    float4 granuleQuaternion = granule.quaternion;

    granuleVelocity = granuleVelocity + granuleAcceleration*_DeltaTime;
    granulePosition = granulePosition + granuleVelocity*_DeltaTime;

    if(granulePosition.y<0&&granuleVelocity.y<0)
    {
        granuleVelocity.y = -granuleVelocity.y;
        granulePosition.y = -granulePosition.y;
    }
    
    _GranuleBuffer[granuleIndex].position = granulePosition;
    _GranuleBuffer[granuleIndex].velocity = granuleVelocity;
    
    
    UpdateParticle(firstParticleIndex);
    UpdateParticle(firstParticleIndex+1);
    UpdateParticle(firstParticleIndex+2);
    UpdateParticle(firstParticleIndex+3);
}

void UpdateParticle(uint particleIndex)
{
    //根据granule的位置和速度，计算particle的位置和速度
    uint granuleIndex = GetGranuleIndex(particleIndex);
    GranuleDataType granule = _GranuleBuffer[granuleIndex];
    float3 granulePosition = granule.position;
    float3 granuleVelocity = granule.velocity;
    float3 granuleAngularVelocity = granule.angularVelocity;
    float4 granuleQuaternion = granule.quaternion;
    float3x3 granuleRotationMatrix = QuaternionToMatrix(granuleQuaternion);
    float3 particlePosition = granulePosition + mul(granuleRotationMatrix,getParticleOffset(particleIndex));
    float3 particleVelocity = granuleVelocity + cross(granuleAngularVelocity,getParticleOffset(particleIndex));

    _ParticlePositionBuffer[particleIndex] = particlePosition;
    _ParticleVelocityBuffer[particleIndex] = particleVelocity;
}

float3x3 QuaternionToMatrix(float4 quaternion)
{
    float3x3 result;
    float x = quaternion.x;
    float y = quaternion.y;
    float z = quaternion.z;
    float w = quaternion.w;
    result[0][0] = 1 - 2*y*y - 2*z*z;
    result[0][1] = 2*x*y - 2*z*w;
    result[0][2] = 2*x*z + 2*y*w;
    result[1][0] = 2*x*y + 2*z*w;
    result[1][1] = 1 - 2*x*x - 2*z*z;
    result[1][2] = 2*y*z - 2*x*w;
    result[2][0] = 2*x*z - 2*y*w;
    result[2][1] = 2*y*z + 2*x*w;
    result[2][2] = 1 - 2*x*x - 2*y*y;
    return result;
}

float3 ParticleContactForceSum(uint particleIndex)
{
    float3 sumForce = float3(0,0,0);

    for(uint i=0;i<(uint)_GranuleCount;i++)
    {
        
        uint firstParticleIndex = GetFirstParticleIndex(i);
        if(GetGranuleIndex(particleIndex)==i)
        {
            continue;
        }
        float3 contactForce = float3(0,0,0);
        contactForce+=CalculateContactForce(particleIndex,firstParticleIndex);
        contactForce+=CalculateContactForce(particleIndex,firstParticleIndex+1);
        contactForce+=CalculateContactForce(particleIndex,firstParticleIndex+2);
        contactForce+=CalculateContactForce(particleIndex,firstParticleIndex+3);
        sumForce+=contactForce;
    }
    
    return sumForce;
}

float3 CalculateContactForce(uint particleIndex1,uint particleIndex2)    //计算两个particle之间的接触力
{
    float overlap_degree = _ParticleRadius*2-length(_ParticlePositionBuffer[particleIndex1]-_ParticlePositionBuffer[particleIndex2]);
    if(overlap_degree<=0)
    {
        return float3(0,0,0);
    }
    float3 contactNormal = normalize(_ParticlePositionBuffer[particleIndex1]-_ParticlePositionBuffer[particleIndex2]);
    float3 contactPointPosition = (_ParticlePositionBuffer[particleIndex1]+_ParticlePositionBuffer[particleIndex2])/2;      //由于半径相同，所以我们认为接触点在两个粒子的连线中点
    uint granuleIndex1 = GetGranuleIndex(particleIndex1);
    GranuleDataType granule1 = _GranuleBuffer[granuleIndex1];
    uint granuleIndex2 = GetGranuleIndex(particleIndex2);
    GranuleDataType granule2 = _GranuleBuffer[granuleIndex2];

    float3 contactPointParticle1Velocity = granule1.velocity + cross(granule1.angularVelocity,contactPointPosition-granule1.position);
    float3 contactPointParticle2Velocity = granule2.velocity + cross(granule2.angularVelocity,contactPointPosition-granule2.position);
    float3 relativeVelocity = contactPointParticle1Velocity - contactPointParticle2Velocity;

    float overlap_velocity = dot(relativeVelocity,contactNormal);
    float3 contactTangentVelocity = relativeVelocity - overlap_velocity*contactNormal;
    float f_normal = -_ViscousDampingCoefficient*sqrt(overlap_degree)*overlap_velocity-_ElasticityRestoringCoefficient*pow(overlap_degree,1.5);
    float f_tangent = -min(_FrictionCoefficient*f_normal,_VelocityDampingCoefficient*length(contactTangentVelocity));
    return f_normal*contactNormal+f_tangent*normalize(contactTangentVelocity);
}



