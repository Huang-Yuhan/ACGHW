// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

#define CS_DEBUG

#ifdef CS_DEBUG

struct GranuleDebugDataType
{
    float3 position;
    float3 velocity;
    float3 angularVelocity;
    float4 quaternion;
    float3 force;
    float3 torque;
    float3 acceleration;
};
RWStructuredBuffer<GranuleDebugDataType> _GranuleDebugBuffer;

#endif

struct GranuleDataType
{
    float3 position;
    float3 velocity;
    float3 angularVelocity;
    float4 quaternion;
};

struct RigidBodyParticleData
{
    float3 position;
};

struct ImpulseDataType
{
    float3 position;
    float3 impulse;
};

struct PlaneData
{
    float3 position;
    float3 normal;
};

RWStructuredBuffer<float3> _ParticlePositionBuffer;
RWStructuredBuffer<float3> _ParticleVelocityBuffer;
RWStructuredBuffer<GranuleDataType> _GranuleBuffer;             //所有的buffer都实际扩大了一倍，分别用于存储当前时刻和下一时刻的数据
StructuredBuffer<RigidBodyParticleData> _RigidBodyParticleBuffer;//用于存储刚体的粒子数据
StructuredBuffer<PlaneData> _PlaneBuffer;
float _DeltaTime;
int _GranuleCount;
int _ParticleCount;
int _RigidBodyParticleCount;
int _PlaneCount;
float _ParticleMass;
float _ParticleRadius;
float _RestitutionCoefficient;
float _FrictionCoefficient;


float4x4 _GranuleInertiaReferenceTensor;


uint _bufferIndexBegin;                             //取值为0或1，表示当前时刻的数据存储在buffer的前半部分还是后半部分

float3 GetParticlePosition(uint particleIndex)
{
    return _ParticlePositionBuffer[particleIndex+_bufferIndexBegin*_ParticleCount];
}
float3 GetParticleVelocity(uint particleIndex)
{
    return _ParticleVelocityBuffer[particleIndex+_bufferIndexBegin*_ParticleCount];
}
GranuleDataType GetGranule(uint granuleIndex)
{
    return _GranuleBuffer[granuleIndex+_bufferIndexBegin*_GranuleCount];
}
void SetParticlePosition(uint particleIndex,float3 position)
{
    _ParticlePositionBuffer[particleIndex+(1-_bufferIndexBegin)*_ParticleCount] = position;
}
void SetParticleVelocity(uint particleIndex,float3 velocity)
{
    _ParticleVelocityBuffer[particleIndex+(1-_bufferIndexBegin)*_ParticleCount] = velocity;
}
void SetGranule(uint granuleIndex,GranuleDataType granule)
{
    _GranuleBuffer[granuleIndex+(1-_bufferIndexBegin)*_GranuleCount] = granule;
}

float4 quaternionMul(float4 q1,float4 q2)
{
    float4 result;
    float s1 = q1.x;
    float s2 = q2.x;
    float3 v1 = q1.yzw;
    float3 v2 = q2.yzw;

    result.x = s1*s2-dot(v1,v2);
    result.yzw = s1*v2+s2*v1+cross(v1,v2);
    
    return result;
}

float3x3 getCrossMatrix(float3 v)
{
    return float3x3(0,-v.z,v.y,
                    v.z,0,-v.x,
                    -v.y,v.x,0);
}

float3x3 GetMatrixInv(float3x3 mat)
{
    float3x3 res;
    float det = mat[0][0]*mat[1][1]*mat[2][2]+mat[0][1]*mat[1][2]*mat[2][0]+mat[0][2]*mat[1][0]*mat[2][1]
                -mat[0][2]*mat[1][1]*mat[2][0]-mat[0][1]*mat[1][0]*mat[2][2]-mat[0][0]*mat[1][2]*mat[2][1];
    float3x3 mat_transpose = transpose(mat);
    res[0][0] = (mat_transpose[1][1]*mat_transpose[2][2]-mat_transpose[1][2]*mat_transpose[2][1])/det;
    res[0][1] = (mat_transpose[0][2]*mat_transpose[2][1]-mat_transpose[0][1]*mat_transpose[2][2])/det;
    res[0][2] = (mat_transpose[0][1]*mat_transpose[1][2]-mat_transpose[0][2]*mat_transpose[1][1])/det;
    res[1][0] = (mat_transpose[1][2]*mat_transpose[2][0]-mat_transpose[1][0]*mat_transpose[2][2])/det;
    res[1][1] = (mat_transpose[0][0]*mat_transpose[2][2]-mat_transpose[0][2]*mat_transpose[2][0])/det;
    res[1][2] = (mat_transpose[0][2]*mat_transpose[1][0]-mat_transpose[0][0]*mat_transpose[1][2])/det;
    res[2][0] = (mat_transpose[1][0]*mat_transpose[2][1]-mat_transpose[1][1]*mat_transpose[2][0])/det;
    res[2][1] = (mat_transpose[0][1]*mat_transpose[2][0]-mat_transpose[0][0]*mat_transpose[2][1])/det;
    res[2][2] = (mat_transpose[0][0]*mat_transpose[1][1]-mat_transpose[0][1]*mat_transpose[1][0])/det;
    return res;
}

static const float3 tetrahedron[4] = {                        
    float3(1,0,-1/sqrt(2)),
    float3(-1,0,-1/sqrt(2)),
    float3(0,1,1/sqrt(2)),
    float3(0,-1,1/sqrt(2))
};

static const float3 g = float3(0,-9.8,0);

void CSMain();
void Simulation(uint3 granuleIndex : SV_DispatchThreadID);
void UpdateParticle(uint particleIndex);
void UpdateGranule(uint granuleIndex);
float3x3 QuaternionToMatrix(float4 quaternion);
GranuleDataType SolveCollision(uint granuleIndex);             //在里面进行碰撞检测和碰撞处理
ImpulseDataType CalculateImpluse(uint granuleIndex,uint particleIndex);
ImpulseDataType CalculateRigidBodyParticleImpluse(uint granuleIndex,uint rigidBodyParticleIndex);
ImpulseDataType CalculatePlaneImpluse(uint granuleIndex,uint planeIndex);

inline uint GetGranuleIndex(uint particleIndex)
{
    return particleIndex/4;
}
inline uint GetFirstParticleIndex(uint granuleIndex)
{
    return granuleIndex*4;
}

float3  getParticleOffset(uint particleIndex)
{
    return tetrahedron[particleIndex%4]*_ParticleRadius;
}

[numthreads(64,1,1)]
void CSMain (uint3 granuleIndex : SV_DispatchThreadID)
{
    Simulation(granuleIndex);
}

void Simulation(uint3 granuleIndex : SV_DispatchThreadID)
{

    UpdateGranule(granuleIndex.x);
}

void UpdateGranule(uint granuleIndex)
{
    #ifdef CS_DEBUG
        _GranuleDebugBuffer[granuleIndex].position = float3(0,0,0);
        _GranuleDebugBuffer[granuleIndex].velocity = float3(0,0,0);
        _GranuleDebugBuffer[granuleIndex].angularVelocity = float3(0,0,0);
        _GranuleDebugBuffer[granuleIndex].quaternion = float4(0,0,0,1);
        _GranuleDebugBuffer[granuleIndex].force = float3(0,0,0);
        _GranuleDebugBuffer[granuleIndex].torque = float3(0,0,0);
        _GranuleDebugBuffer[granuleIndex].acceleration = float3(0,0,0);
    #endif
    
    uint firstParticleIndex = GetFirstParticleIndex(granuleIndex);

    GranuleDataType granule = GetGranule(granuleIndex);

    float3 granulePosition = granule.position;
    float3 granuleVelocity = granule.velocity;
    float3 granuleAngularVelocity = granule.angularVelocity;
    float4 granuleQuaternion = granule.quaternion;
    
    GranuleDataType res = SolveCollision(granuleIndex);

    res.velocity = res.velocity*0.99;
    res.angularVelocity = res.angularVelocity*0.99;

    res.position += res.velocity*_DeltaTime;
    float3 temp = granuleAngularVelocity*_DeltaTime/2;
    res.quaternion = quaternionMul(float4(0,temp),res.quaternion)+res.quaternion;
    res.quaternion = normalize(res.quaternion);
    
    SetGranule(granuleIndex,res);
    
    UpdateParticle(firstParticleIndex);
    UpdateParticle(firstParticleIndex+1);
    UpdateParticle(firstParticleIndex+2);
    UpdateParticle(firstParticleIndex+3);
}

void UpdateParticle(uint particleIndex)
{
    //根据granule的位置和速度，计算particle的位置和速度
    uint granuleIndex = GetGranuleIndex(particleIndex);
    GranuleDataType granule = _GranuleBuffer[granuleIndex+(1-_bufferIndexBegin)*_GranuleCount];                         //这里需要用到计算后的数据，所以不能用GetGranule函数
    float3 granulePosition = granule.position;
    float3 granuleVelocity = granule.velocity;
    float3 granuleAngularVelocity = granule.angularVelocity;
    float4 granuleQuaternion = granule.quaternion;
    float3x3 granuleRotationMatrix = QuaternionToMatrix(granuleQuaternion);
    float3 particlePosition = granulePosition + mul(granuleRotationMatrix,getParticleOffset(particleIndex));
    float3 particleVelocity = granuleVelocity + cross(granuleAngularVelocity,particlePosition-granulePosition);

    /*_ParticlePositionBuffer[particleIndex] = particlePosition;
    _ParticleVelocityBuffer[particleIndex] = particleVelocity;*/
    SetParticlePosition(particleIndex,particlePosition);
    SetParticleVelocity(particleIndex,particleVelocity);
}

float3x3 QuaternionToMatrix(float4 quaternion)
{
    float3x3 result;
    float s= quaternion.x;
    float3 v = quaternion.yzw;
    result[0][0] = 1-2*v.y*v.y-2*v.z*v.z;
    result[0][1] = 2*v.x*v.y-2*s*v.z;
    result[0][2] = 2*v.x*v.z+2*s*v.y;
    result[1][0] = 2*v.x*v.y+2*s*v.z;
    result[1][1] = 1-2*v.x*v.x-2*v.z*v.z;
    result[1][2] = 2*v.y*v.z-2*s*v.x;
    result[2][0] = 2*v.x*v.z-2*s*v.y;
    result[2][1] = 2*v.y*v.z+2*s*v.x;
    result[2][2] = 1-2*v.x*v.x-2*v.y*v.y;
    return result;
}


GranuleDataType SolveCollision(uint granuleIndex)                //在里面进行碰撞检测和碰撞处理
{
    GranuleDataType res = GetGranule(granuleIndex);

    res.velocity+=g*_DeltaTime;

    float3x3 granuleRotationMatrix = QuaternionToMatrix(res.quaternion);
    float3x3 InertiaReferenceTensorInv = float3x3(1/_GranuleInertiaReferenceTensor[0][0],0,0,
                                                  0,1/_GranuleInertiaReferenceTensor[1][1],0,
                                                  0,0,1/_GranuleInertiaReferenceTensor[2][2]);
    float3x3 InertiaTensorInv = mul(mul(granuleRotationMatrix,InertiaReferenceTensorInv),transpose(granuleRotationMatrix));


    //这里先只计算平面的碰撞
    for(int i=0;i<_PlaneCount;i++)
    {
        ImpulseDataType impulse = CalculatePlaneImpluse(granuleIndex,i);
        res.velocity += impulse.impulse/_ParticleMass/4;
        res.angularVelocity += mul(InertiaTensorInv,cross(impulse.position-res.position,impulse.impulse));
    }
    
    
    return res;
}

ImpulseDataType CalculateImpluse(uint granuleIndex,uint particleIndex)
{
    ImpulseDataType res;
    res.impulse = float3(0,0,0);
    res.position = float3(0,0,0);
    return res;
}
ImpulseDataType CalculateRigidBodyParticleImpluse(uint granuleIndex,uint rigidBodyParticleIndex)
{
    ImpulseDataType res;
    res.impulse = float3(0,0,0);
    res.position = float3(0,0,0);
    return res;
}
ImpulseDataType CalculatePlaneImpluse(uint granuleIndex,uint planeIndex)
{
    ImpulseDataType res;
    res.impulse = float3(0,0,0);
    res.position = float3(0,0,0);
    
    uint firstParticleIndex = GetFirstParticleIndex(granuleIndex);
    GranuleDataType granule = GetGranule(granuleIndex);
    float dis=0;
    float3 pointOnPlane = _PlaneBuffer[planeIndex].position;
    float3 planeNormal = _PlaneBuffer[planeIndex].normal;

    //计算粒子到平面的距离

    float average_mass = 0;
    float3 average_position = float3(0,0,0);
    
    for(int i=0;i<4;i++)
    {
        float3 particlePosition = GetParticlePosition(firstParticleIndex+i);
        dis = dot(particlePosition-pointOnPlane,planeNormal);
        float3 particleProjectionOnPlane = particlePosition-dis*planeNormal;
        if(dis-_ParticleRadius<0)           //说明球体与平面相交
        {
            float alpha = acos(clamp(dis/_ParticleRadius,-1,1));
            float dm = (1-cos(alpha))*_ParticleMass/2;
            float ydm = -_ParticleRadius/4*sin(alpha)*sin(alpha)*_ParticleMass;
            average_mass+=dm;
            average_position+=particlePosition+planeNormal*ydm;
        }
    }
    if(average_mass==0)
    {
        return res;
    }
    
    average_position/=average_mass;
    
    float3 relativePoint = average_position-granule.position;
    float3 relativeVelocity = granule.velocity+cross(granule.angularVelocity,relativePoint);

    #ifdef CS_DEBUG
        _GranuleDebugBuffer[granuleIndex].position = relativePoint;
        _GranuleDebugBuffer[granuleIndex].velocity = relativeVelocity;
    #endif

    if(dot(relativeVelocity,planeNormal)>0)
    {
        return res;
    }

    float3 v_normal = dot(relativeVelocity,planeNormal)*planeNormal;
    float3 v_tangent = relativeVelocity-v_normal;
    float a = max(0,1-_FrictionCoefficient*(1+_RestitutionCoefficient)*length(v_normal)/length(v_tangent));
    float3 v_new_normal = -_RestitutionCoefficient*v_normal;
    float3 v_new_tangent = a*v_tangent;
    float3 v_new = v_new_normal+v_new_tangent;

    float3x3 RriStarMatrix=getCrossMatrix(relativePoint);
    float3x3 InertiaReferenceTensorInv = float3x3(1/_GranuleInertiaReferenceTensor[0][0],0,0,
                                                  0,1/_GranuleInertiaReferenceTensor[1][1],0,
                                                  0,0,1/_GranuleInertiaReferenceTensor[2][2]);
    float3x3 rotationMatrix = QuaternionToMatrix(granule.quaternion);
    float3x3 InertiaTensorInv = mul(mul(rotationMatrix,InertiaReferenceTensorInv),transpose(rotationMatrix));
    float3x3 K = float3x3(0.25f/_ParticleMass,0,0,
                          0,0.25f/_ParticleMass,0,
                          0,0,0.25f/_ParticleMass)-mul(mul(RriStarMatrix,InertiaTensorInv),RriStarMatrix);

    float3 J = mul(GetMatrixInv(K),v_new-relativeVelocity);

    #ifdef CS_DEBUG
        _GranuleDebugBuffer[granuleIndex].force = J;
    #endif
    
    res.impulse = J;
    res.position = average_position;
    return res;
}